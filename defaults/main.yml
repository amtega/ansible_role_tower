---
# Role default lower priority variables

# Tower version. If not defined the role will take the last version available in
# official repository

#tower_version:

# Type of tower product. Can be rh (Red Hat Tower) or awx (The FLOSS version of
# tower)

tower_type: awx

# Tower state. Can be present or absent

tower_state: present

# Admin password. Only used during install

tower_admin_password: password

# Host url to use for config items management

tower_host: "http://localhost:{{ tower_nginx_http_port }}"

# Username to use for config items management

tower_username: admin

# Password to use for config items management

tower_password: "{{ tower_admin_password }}"

# Dictionary with the tower license info

#tower_license:

# Verify or not SSL certs from AWX host url

tower_validate_certs: no

# NGINX ports

tower_nginx_http_port: 80
tower_nginx_disable_https: yes
tower_nginx_https_port: 443

# Postgresql settings (only for rh tower)

tower_pg_host: ""
tower_pg_port: ""

tower_pg_database: tower
tower_pg_username: tower
tower_pg_password: tower

# Postgresql software collection package (only for awx)

tower_pg_scl_package: rh-postgresql10

# Rabbitmq settings (only for rh tower)

tower_rabbitmq_port: 5672
tower_rabbitmq_vhost: tower
tower_rabbitmq_username: tower
tower_rabbitmq_password: tower
tower_rabbitmq_cookie: cookiemonster

# Rabbitmq repository settings (only for awx)

tower_rabbitmq_repo_url: >-
  https://dl.bintray.com/rabbitmq/rpm/rabbitmq-server/v3.7.x/el/7/
tower_rabbitmq_erlang_repo_url: >-
   https://dl.bintray.com/rabbitmq-erlang/rpm/erlang/21/el/7/

# Python software collection (only for awx)

tower_python_scl_package: rh-python36

# Git software collection (only for awx)

tower_git_scl_package: rh-git218

# Force install even if the role detects that it is not necessary

tower_force_install: no

# List of strings with the install extra arguments. See tower quick install
# guide for details

tower_install_args: []

# List of operating system packages to install (only for awx)

tower_install_os_packages:
  - "@Development Tools"
  - memcached
  - nginx
  - python-devel
  - rabbitmq-server
  - redis
  - "{{ tower_git_scl_package }}"
  - "{{ tower_pg_scl_package }}-postgresql-server"
  - "{{ tower_python_scl_package }}"
  - "{{ tower_python_scl_package }}-django-split-settings"
  - "{{ tower_python_scl_package }}-sqlparse"
  - "{{ tower_python_scl_package }}-ansible"
  - "{{ tower_python_scl_package }}-asgiref"
  - "{{ tower_python_scl_package }}-boto"
  - scl-utils

# List of python packages to install (only for awx)

tower_install_python_packages:
  - Django==2.2.8
  - channels==1.1.8
  - asgiref==1.1.2
  - django-split-settings
  - prometheus_client
  - django-qsstats-magic
  - ansiconv
  - python3-memcached
  - schedule
  - attrs==19.2.0
  - asgi_amqp
  - uwsgi
  - radius
  - django-radius
  - tacacs_plus
  - onelogin
  - python3-saml
  - automat==20.2.0

# Ignore errors during tower assets configuration

tower_ignore_errors: no

# Become method to change to awx users

tower_become_method: su

# List of dicts with the settings to setup. Each dict can contain the following
# attributes with the same meaning that in ansible `tower_settings` module:
#
# - name
#   value
#
# Additionally you can pass the key `update` with a boolean value to indicate if
# the setting should be updated or not (default is true). This is useful to
# manage idempotence in options like passwords

tower_settings: []

# Indicate `tower_settings` must be loaded also from host variables. Any host
# variable that begins with "tower_settings_*" and contains the necessary
# attributes will be loaded as an item to manage by the role. The variables must
# follow the structure detailed before for `tower_settings`

tower_settings_load_from_hostvars: no

# List of dicts with the organizations to setup. Each dict can contain the
# following attributes with the same meaning that in ansible
# `tower_organization` module:
#
# - description
# - name
# - state

tower_organizations: []

# Dictionary with the defaults options to use if no other ones are specified in
# the `tower_orga√ß` variable. The members of the dict are the same attributes
# that the ones expected by the ansible `tower_organization` module

tower_organizations_defaults: {}

# Indicate `tower_organizations` must be loaded also from host variables. Any
# host variable that begins with "tower_organizations_*" and contains the
# necessary attributes will be loaded as an item to manage by the role. The
# variables must follow the structure detailed before for `tower_organizations`

tower_organizations_load_from_hostvars: no

# List of dicts with the teams to setup. Each dict can contain the following
# attributes with the same meaning that in ansible `tower_team` module:
#
# - name
# - organization
# - state

tower_teams: []

# Dictionary with the defaults options to use if no other ones are specified in
# the `tower_teams` variable. The members of the dict are the same attributes
# that the ones expected by the ansible `tower_team` module

tower_teams_defaults: {}

# Indicate `tower_teams` must be loaded also from host variables. Any host
# variable that begins with "tower_teams_*" and contains the necessary
# attributes will be loaded as an item to manage by the role. The variables must
# follow the structure detailed before for `tower_teams`

tower_teams_load_from_hostvars: no

# List of dicts with the users to setup. Each dict can contain the following
# attributes with the same meaning that in ansible `tower_user` module:
#
# - auditor
# - email
# - first_name
# - last_name
# - password
# - state
# - superuser
# - username
#
# Additionally the following attributes can be used:
#
# - force_update: <yes|no>     # Force update. Needed if passwords were changed

tower_users: []

# Dictionary with the defaults options to use if no other ones are specified in
# the `tower_users` variable. The members of the dict are the same attributes that
# the ones expected by the ansible `tower_user` module

tower_users_defaults: {}

# Indicate `tower_users` must be loaded also from host variables. Any host
# variable that begins with "tower_users_*" and contains the necessary
# attributes will be loaded as an item to manage by the role. The variables must
# follow the structure detailed before for `tower_users`

tower_users_load_from_hostvars: no

# List of dicts with the credentials to setup. Each dict can contain the
# following attributes with the same meaning that in ansible `tower_credential`
# module:
#
# - authorize
# - authorize_password
# - become_method
# - become_password
# - become_username
# - client
# - description
# - domain
# - host
# - kind
# - name
# - organization
# - password
# - project
# - secret
# - security_token
# - ssh_key_data
# - ssh_key_unlock
# - state
# - subscription
# - team
# - tenant
# - user
# - username
# - vault_password
#
# Additionally the following attributes can be used:
#
# - force_update: <yes|no>     # Force update. Needed if passwords were changed

tower_credentials: []

# Dictionary with the defaults options to use if no other ones are specified in
# the `tower_credentials` variable. The members of the dict are the same
# attributes that the ones expected by the ansible `tower_credential` module:

tower_credentials_defaults: {}

# Indicate `tower_credentials` must be loaded also from host variables. Any host
# variable that begins with "tower_credentials_*" and contains the necessary
# attributes will be loaded as an item to manage by the role. The variables must
# follow the structure detailed before for `tower_credentials`

tower_credentials_load_from_hostvars: no

# List of dicts with the projects to setup. Each dict can contain the following
# attributes with the same meaning that in ansible `tower_project` module:
#
# - custom_virtualenv
# - description
# - local_path
# - name
# - organization
# - scm_branch
# - scm_clean
# - scm_credential
# - scm_delete_on_update
# - scm_type
# - scm_update_cache_timeout
# - scm_update_on_launch
# - scm_url
# - state

tower_projects: []

# Dictionary with the defaults options to use if no other ones are specified in
# the `tower_projects` variable. The members of the dict are the same
# attributes that the ones expected by the ansible `tower_project` module

tower_projects_defaults: {}

# Number of retries to get a success state after managing a project

tower_projects_get_status_retries: 5

# Number of seconds to wait between project state checks

tower_projects_get_status_delay: 10

# Indicate `tower_projects` must be loaded also from host variables. Any host
# variable that begins with "tower_projects_*" and contains the necessary
# attributes will be loaded as an item to manage by the role. The variables must
# follow the structure detailed before for `tower_projects`

tower_projects_load_from_hostvars: no

# List of dicts with the inventories to setup. Each dict can contain the
# following attributes with the same meaning that in ansible `tower_inventory`
# module:
#
# - description
# - host_filter
# - kind
# - name
# - organization
# - state
# - variables
#
# Additionally you can specify the inventory sources to use as a list of dicts
# in the attribute `sources`. The members of each dict are the same attributes
# that the ones expected by the ansible `tower_inventory_source` module:
#
# - credential
# - description
# - group_by
# - instance_filters
# - inventory
# - name
# - overwrite
# - overwrite_vars
# - source
# - source_path
# - source_project
# - source_regions
# - source_script
# - source_vars
# - state
# - timeout
# - update_cache_timeout
# - update_on_launch

tower_inventories: []

# Dictionary with the defaults options to use if no other ones are specified in
# the `tower_inventories` variable. The members of the dict are the same
# attributes that the ones expected by the ansible `tower_inventory` module

tower_inventories_defaults: {}

# Dictionary with the defaults options to use if no other ones are specified in
# the `tower_inventories.sources` items. The members of the dict are the same
# attributes that the ones expected by the ansible `tower_inventory_source`
# module

tower_inventories_sources_defaults: {}

# Indicate `tower_inventories` must be loaded also from host variables. Any host
# variable that begins with "tower_inventories_*" and contains the necessary
# attributes will be loaded as an item to manage by the role. The variables must
# follow the structure detailed before for `tower_inventories`

tower_inventories_load_from_hostvars: no

# List of dicts with the job templates to setup. Each dict can contain the
# following attributes with the same meaning that in ansible
# `tower_job_template` module:
#
# - ask_credential
# - ask_diff_mode
# - ask_extra_vars
# - ask_inventory
# - ask_job_type
# - ask_limit
# - ask_skip_tags
# - ask_tags
# - ask_verbosity
# - become_enabled
# - concurrent_jobs_enabled
# - description
# - extra_vars_path
# - fact_caching_enabled
# - force_handlers_enabled
# - forks
# - host_config_key
# - inventory
# - job_tags
# - job_type
# - limit
# - name
# - playbook
# - project
# - skip_tags
# - start_at_task
# - state
# - survey_enabled
# - verbosity
#
# Also, you can provide to the previous template dictionary the attribute
# `credentials` containing a list of dictionarires with the credentials to apply
# to the template. The structure of this dict is the following:
#
# {
#   name: <name>            # Name of the credential
#   type: <string>          # Type of credential. See tower docs for details
#   state: <state>          # State of the credential. Can be present or absent
# }
#
# Also, you can provide to the previous template dictionary the attribute
# `schedules` containing a list of dictionarires with the schedules to apply to
# the template. The structure of this dict is the following:
#
# {
#   name: <name>            # Name of the schedule
#   rrule: <ical>           # iCal recurrence rule fot the schedule
#   extra_data: <data>      # Extra data to run the schedule
#   enabled: <yes_no>       # Enable or not the schedule
#   state: <state>          # State of the shedule. Can be present or absent
# }
#
# Also, you can provide to the previous template dictionary the attribute
# `roles` containing a list of dictionarires with the roles to apply to the
# template. The structure of this dict is the following:
#
# {
#   role: <role>            # Role to assign
#   team: <team>            # Team to apply the role
#   user: <user>            # User to apply the role
#   state: <state>          # State of the role. Can be present or absent
#                           # Default is present
# }

tower_templates: []

# Dictionary with the defaults options to use if no other ones are specified in
# the `tower_templates` variable. The members of the dict are the same attributes
# that the ones expected by the ansible `tower_inventory_source` module

tower_templates_defaults: {}

# Number of retries to get a success state after managing a template

tower_templates_get_status_retries: 5

# Number of seconds to wait between template state checks

tower_templates_get_status_delay: 10

# Indicate `tower_templates` must be loaded also from host variables. Any host
# variable that begins with "tower_templates_*" and contains the necessary
# attributes will be loaded as an item to manage by the role. The variables must
# follow the structure detailed before for `tower_templates`

tower_templates_load_from_hostvars: no

# List of dicts with the job workflows to setup. Each dict can contain the
# following attributes with the same meaning that in ansible
# `tower_workflow_template` module:
#
# - ask_simultaneous
# - ask_extra_vars
# - ask_inventory
# - description
# - extra_vars_path
# - inventory
# - name
# - organization
# - playbook
# - state
# - survey_enabled
#
# Also, you can provide to the previous workflow dictionary the attribute
# `schedules` containing a list of dictionarires with the schedules to apply to
# the workflow. The structure of this dict is the following:
#
# {
#   name: <name>            # Name of the schedule
#   rrule: <ical>           # iCal recurrence rule fot the schedule
#   extra_data: <data>      # Extra data to run the schedule
#   enabled: <yes_no>       # Enable or not the schedule
#   state: <state>          # State of the shedule. Can be present or absent
# }
#
# Also, you can provide to the previous workflow dictionary the attribute
# `roles` containing a list of dictionarires with the roles to apply to the
# workflow. The structure of this dict is the following:
#
# {
#   role: <role>            # Role to assign
#   team: <team>            # Team to apply the role
#   state: <state>          # State of the role. Can be present or absent
#                           # Default is present
# }

tower_workflows: []

# Dictionary with the defaults options to use if no other ones are specified in
# the `tower_workflows` variable. The members of the dict are the same
# attributes that the ones expected by the ansible `tower_inventory_source`
# module

tower_workflows_defaults: {}

# Number of retries to get a success state after managing a workflow

tower_workflows_get_status_retries: 5

# Number of seconds to wait between workflow state checks

tower_workflows_get_status_delay: 10

# Indicate `tower_workflows` must be loaded also from host variables. Any host
# variable that begins with "tower_workflows_*" and contains the necessary
# attributes will be loaded as an item to manage by the role. The variables must
# follow the structure detailed before for `tower_workflows`

tower_workflows_load_from_hostvars: no

# Indicate if workflows nodes muste be configured.

tower_workflows_setup_nodes: yes

# Indicate wich items to setup for tower resources

tower_resources_setup_virtualenvs: yes
tower_resources_setup_surveys: yes
tower_resources_setup_credentials: yes
tower_resources_setup_schedules: yes
tower_resources_setup_roles: yes

# Artifact download config. This is only used when variable `tower_type` is set
# to `rh`
#
# The role will try to identify the Tower artifact to download from the the
# official site.
#
# If you want to download the artifact from another repository yo need to
# configure the `tower_artifact` variable to point to a local/public repository
# that contains the required artifact
#
# Take a look to `amtega.artifact` role documentation to known about supported
# types of artifacts, their specific settings and how to configure a proxy if
# necessary. The attributes `id`, `unarchive` of the artifact will be overriden,
# so they are not mandatory

# tower_artifact:

# Hide sensitive information

tower_no_log: yes
